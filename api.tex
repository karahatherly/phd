
\chapter{MCS API}
\label{appendix:api}

\newcommand{\apidoc}[6]
{
    \subsection{\label{api:#1}#2}
    \code{#4}\\
    \vspace{3pt}\\
    \noindent
    #3\\
    \vspace{3pt}\\
    \begin{tabularx}{\textwidth}{llX}\toprule
        \emph{Type} & \emph{Parameter} & \emph{Description} \\\midrule
         #5
        \bottomrule
    \end{tabularx}
    \vspace{3pt}\\
    \noindent
    \textit{Return value:} #6 
}

\newcommand{\param}[3]
{
\texttt{#1} & \texttt{#2} & #3 \\
}
\section{System calls}

For convenience, in this section we present all of the system calls in the MCS api.

\apidoc{call}
{Call}
{Invoke the capability provided and block waiting on a reply. Used to communicate with the kernel 
 to invoke objects, or for \gls{IPC} when used on an endpoint capability. When used for \gls{IPC}, 
  the scheduling context of the caller may be lent to the receiver. The caller is blocked on a
  resume object, and wakes once that resume object has been invoked, thus sending a reply and
  returning a lent scheduling context.}
  {seL4\_MessageInfo\_t seL4\_Call(seL4\_CPtr cap, \code{seL4\_MessageInfo\_t} info)}
{
    \param{seL4\_CPtr}{dest}{Capability to invoke}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
}
{an \code{seL4\_MessageInfo\_t} structure encoding details about the reply message.}

\apidoc{send}
{Send}
{Invoke the capability provided. If used on an endpoint capability, block until the message has been
sent.}
{void seL4\_Send(seL4\_CPtr cap, \code{seL4\_MessageInfo\_t} info)}
{
    \param{seL4\_CPtr}{dest}{Capability to invoke}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
}
{none.}

\apidoc{nbsend}
{NBSend}
{Invoke the capability provided. If used on an endpoint capability and no receiver is present, do
    not send the message and return immediately.}
{void seL4\_NBSend(seL4\_CPtr cap, \code{seL4\_MessageInfo\_t} info)}
{
    \param{seL4\_CPtr}{dest}{Capability to invoke}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
}
{none}

\apidoc{recv}
{Recv}
{Wait for a message on the provided capability. If the provided capability is not an endpoint or
    notification, raise a capability fault. Passive threads may receive scheduling contexts from 
this system call.}
    {seL4\_MessageInfo\_t seL4\_Recv(seL4\_CPtr cap, seL4\_Word *badge, seL4\_CPtr reply)}
{
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
    \param{seL4\_CPtr}{reply}{Capability to the resume object to block callers on.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}


\apidoc{nbrecv}
{NBRecv}
{Poll for a message on the provided capability. If the provided capability is not an endpoint or
    notification, raise a capability fault. Passive threads may receive scheduling contexts from 
this system call.}
    {seL4\_MessageInfo\_t seL4\_NBRecv(seL4\_CPtr cap, seL4\_Word *badge, seL4\_CPtr reply)}
{
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
    \param{seL4\_CPtr}{reply}{Capability to the resume object to block callers on.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{wait}
{Wait}
{Wait for a message on the provided capability. If the provided capability is not an endpoint or
    notification, raise a capability fault.}
    {seL4\_MessageInfo\_t seL4\_Wait(seL4\_CPtr cap, seL4\_Word *badge)}
{
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{nbwait}
{NBWait}
{Poll for a message on the provided capability. If the provided capability is not an endpoint or
    notification, raise a capability fault.}
    {seL4\_MessageInfo\_t seL4\_NBWait(seL4\_CPtr cap, seL4\_Word *badge)}
{
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{replyrecv}
{ReplyRecv}
{Invoke a resume object, sending a reply message, then block on the provided capability, waiting for
a message on the provided capability, with the now cleared resume object. Passive threads may receive
scheduling contexts from  this system call.}
{seL4\_MessageInfo\_t seL4\_ReplyRecv(seL4\_CPtr cap, \code{seL4\_MessageInfo\_t} info, seL4\_Word *badge,
seL4\_CPtr reply)}
{
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
    \param{seL4\_CPtr}{reply}{Capability to the resume object to block callers on.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{nbsendrecv}
{NBSendRecv}
{Perform a non-blocking send on a capability, then block on the provided capability, waiting for
a message on the provided capability, with the resume object. Passive threads may receive
scheduling contexts from this system call.}
{seL4\_MessageInfo\_t seL4\_NBSendRecv(seL4\_CPtr dest, \code{seL4\_MessageInfo\_t} info, seL4\_CPtr src,
    seL4\_Word *badge, seL4\_CPtr reply)}
{
    \param{seL4\_CPtr}{dest}{Capability to invoke}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
    \param{seL4\_CPtr}{reply}{Capability to the resume object to block callers on.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{nbsendwait}
{NBSendWait}
{Perform a non-blocking send on a capability, then block on the provided capability, waiting for
a message on the provided capability.}
{seL4\_MessageInfo\_t seL4\_NBSendWait(seL4\_CPtr dest, \code{seL4\_MessageInfo\_t} info, seL4\_CPtr src,
    seL4\_Word *badge)}
{
    \param{seL4\_CPtr}{dest}{Capability to invoke}
    \param{seL4\_CPtr}{info}{A \code{seL4\_MessageInfo\_t} structure encoding details about the message}
    \param{seL4\_CPtr}{src}{Capability to wait for a message on.}
    \param{seL4\_Word*}{badge}{address for the kernel to write the badge value of the sender to.}
}
{An \code{seL4\_MessageInfo\_t} structure encoding details about the message received.}

\apidoc{yield}
{Yield}
{Exhaust the head replenishment of the current thread and place the thread at the end of the
scheduling queue, or into the release queue if the next replenishment is not yet available.}
{void seL4\_Yield(void)}
{\param{void}{}{}}
{none}


\section{Invocations}

In this section, we only present invocations added or changed by the MCS scheduling API, the rest
can be found in the seL4 manual~\citep{seL417}. 

\subsection{Scheduling context invocations}
\label{api:sc}
\apidoc
{schedcontext_bind}
{SchedContext - Bind}
{ Bind a scheduling context to a provided TCB or Notification object. None of the objects (SC, TCB
or Notification) can be already bound to other objects. If the TCB is in a runnable state and the
scheduling context has available budget, this operation will place the TCB in the scheduler at the
TCB's priority.}
{seL4\_Error seL4\_SchedContext\_Bind(seL4\_CPtr sc, seL4\_CPtr cap)}
{
    \param{seL4\_CPtr}{sc}{Capability to the SC to bind an object to.}
    \param{seL4\_CPtr}{cap}{Capability to a TCB or Notification object to bind to this SC.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{schedcontext_unbind}
{SchedContext - Unbind}
{ Remove any objects bound to a specific scheduling context.}
{seL4\_Error seL4\_SchedContext\_Unbind(seL4\_CPtr sc)}
{
    \param{seL4\_CPtr}{sc}{Capability to the SC to unbind an object to.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{schedcontext_unbind_object}
{SchedContext - UnbindObject}
{ Remove a specific object bound to a specific scheduling context.}
{seL4\_Error seL4\_SchedContext\_UnbindObject(seL4\_CPtr sc, seL4\_CPtr cap)}
{
    \param{seL4\_CPtr}{sc}{Capability to the SC to unbind an object to.}
    \param{seL4\_CPtr}{cap}{Capability to a TCB or Notification object to unbind from this SC.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{schedcontext_consumed}
{SchedContext - Consumed}
{ Return the amount of time used by this scheduling context since this function
    was last called or a timeout fault triggered.}
    {seL4\_Error seL4\_SchedContext\_Consumed(seL4\_CPtr sc)}
{
    \param{seL4\_CPtr}{sc}{Capability to the SC to act on.}
}
{An error code and a \code{uint64\_t} consumed value.}

\apidoc
{schedcontext_yieldto}
{SchedContext - YieldTo}
{ 
   If a thread is currently runnable and running on this scheduling context and the scheduling context has available budget, place it at the head of the scheduling queue.
              If the caller is at an equal priority to the thread this will result in the thread being scheduled.
              If the caller is at a higher priority the thread will not run until the threads priority is the highest priority in the system.
              The caller must have a maximum control priority greater than or equal to the threads priority.
}
{seL4\_Error seL4\_SchedContext\_YieldTo(seL4\_CPtr sc)}
{
    \param{seL4\_CPtr}{sc}{Capability to the SC to act on.}
}
{An error code and a \code{uint64\_t} consumed value.}

\subsection{Sched\_control Invocations}
\apidoc
{schedcontrol_configure}
{SchedControl - Configure}
{ Configure a scheduling context by invoking a \code{sched\_control} capability. The scheduling
context will inherit the affinity of the provided \code{sched\_control}.}
{seL4\_Error seL4\_SchedControl\_Configure(seL4\_CPtr sched\_control, seL4\_CPtr sc, uint64\_t
budget, uint64\_t period, seL4\_Word extra\_refills, seL4\_Word badge)}
{
    \param{seL4\_CPtr}{sched\_control}{\code{sched\_control} capability to invoke to configure
    the SC.}
    \param{seL4\_CPtr}{sc}{Capability to the SC to configure.}
    \param{uint64\_t}{budget}{Timeslice in microseconds.}
    \param{uint64\_t}{period}{Period in microseconds, if equal to budget, this thread will be
        treated as a round-robin thread. Otherwise, sporadic servers will be used to assure the
    scheduling context does not exceed the budget over the specified period.}
    \param{seL4\_Word}{extra\_refills}{Number of extra sporadic replenishments this scheduling
    context should use. Ignored for round-robin threads. The maximum value is determined by the size
of the SC that is being configured.}
    \param{seL4\_Word}{badge}{Badge value that is delivered to timeout fault handlers}
}
{0 on success, seL4\_Error code on error.}

\subsection{TCB Invocations}

\apidoc
{tcb_configure}
{TCB - Configure}
{Set the parameters of a TCB.}
{seL4\_Error seL4\_TCB\_Configure(seL4\_CPtr tcb, seL4\_CPtr cnode, seL4\_Word guard, seL4\_CPtr
vspace, seL4\_Word vspace\_data, seL4\_Word buffer, seL4\_CPtr buffer\_cap)}
{
    \param{seL4\_CPtr}{tcb}{Capability to the TCB to configure.}
    \param{seL4\_CPtr}{cnode}{Root cnode for this TCB.}
    \param{seL4\_Word}{guard}{Optionally set the guard and guard size of the new root CNode. If set to zero, this parameter has no effect.}
    \param{seL4\_CPtr}{vspace}{Top level paging structure for this TCB.}
    \param{seL4\_Word}{vspace\_data}{Has no effect on x86 or ARM processors.}
    \param{seL4\_Word}{buffer}{Location of the thread's IPC buffer.}
    \param{seL4\_CPtr}{buffer\_cap}{Capability to the frame containing the thread's IPC buffer.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{tcb_setmcpriority}
{TCB - SetMCPriority}
{Set the maximum control priority of a TCB.}
{seL4\_Error seL4\_TCB\_SetMCPriority(seL4\_CPtr tcb, seL4\_CPtr auth, seL4\_Word mcp)}
{
    \param{seL4\_CPtr}{tcb}{Capability to the TCB to configure.}
    \param{seL4\_CPtr}{auth}{Capability to the TCB to use the MCP from when setting the new MCP.}
    \param{seL4\_Word}{mcp}{Value for the new MCP.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{tcb_setpriority}
{TCB - SetPriority}
{Set the priority of a TCB.}
{seL4\_Error seL4\_TCB\_SetPriority(seL4\_CPtr tcb, seL4\_CPtr auth, seL4\_Word prio)}
{
    \param{seL4\_CPtr}{tcb}{Capability to the TCB to configure.}
    \param{seL4\_CPtr}{auth}{Capability to the TCB to use the MCP from when setting the new MCP.}
    \param{seL4\_Word}{prio}{Value for the new priority.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{tcb_setschedparams}
{TCB - SetSchedParams}
{Set the scheduling parameters of a TCB.}
{seL4\_Error seL4\_TCB\_SetSchedParams(seL4\_CPtr tcb, seL4\_CPtr auth, seL4\_Word mcp,
                                       seL4\_Word prio, seL4\_CPtr sc, seL4\_CPtr fault\_ep)}
{
    \param{seL4\_CPtr}{tcb}{Capability to the TCB to configure.}
    \param{seL4\_CPtr}{auth}{Capability to the TCB to use the MCP from when setting the new MCP.}
    \param{seL4\_Word}{mcp}{Value for the new MCP.}
    \param{seL4\_Word}{prio}{Value for the new priority.}
    \param{seL4\_CPtr}{sc}{Capability of the sc to bind to this TCB.}
    \param{seL4\_CPtr}{fault\_ep}{Capability to the endpoint to set as the fault endpoint for this TCB.}
}
{0 on success, seL4\_Error code on error.}

\apidoc
{tcb_settimeoutep}
{TCB - SetTimeoutEndpoint}
{Set the timeout endpoint of a TCB.}
{seL4\_Error seL4\_TCB\_SetTimeoutEndpoint(seL4\_CPtr tcb, seL4\_CPtr ep)}
{
    \param{seL4\_CPtr}{tcb}{Capability to the TCB to configure.}
    \param{seL4\_CPtr}{ep}{Capability to the endpoint to set as the timeout endpoint for this TCB.}
}
{0 on success, seL4\_Error code on error.}
